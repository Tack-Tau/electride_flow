#!/usr/bin/env python3
"""
Generate energy comparison plots from pre-computed JSON results.

This script reads JSON files generated by compute_dft_e_hull.py and compare_energy_methods.py
and regenerates all comparison plots without needing to re-parse VASP outputs.

Usage:
    python3 e_hull_energy_plot.py --results-dir <path_to_json_files>

Example:
    python3 e_hull_energy_plot.py --results-dir Bin-Ele-HT/prescreen_results
    python3 e_hull_energy_plot.py --results-dir Ter-Ele-HT/prescreen_results
"""

import os
import sys
import json
import argparse
import numpy as np
from pathlib import Path
from pymatgen.core import Composition

import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib.colors import LinearSegmentedColormap
from scipy.stats import gaussian_kde

mpl.use('Agg')


def load_json_file(filepath):
    """Load JSON file safely."""
    filepath = Path(filepath)
    if not filepath.exists():
        print(f"ERROR: File not found: {filepath}")
        return None
    
    print(f"  Loading {filepath.name}...")
    with open(filepath, 'r') as f:
        return json.load(f)


def extract_mp_id(entry_id):
    """
    Extract base MP ID from various formats.
    
    Examples:
        'mp_mattersim_mp-12345' -> 'mp-12345'
        'mp-12345-GGA' -> 'mp-12345'
        'mp-12345' -> 'mp-12345'
    """
    if 'mp_mattersim_' in entry_id:
        mp_id = entry_id.split('mp_mattersim_')[1]
    else:
        mp_id = entry_id
    
    # Remove functional suffixes
    mp_id = mp_id.split('-GGA')[0].split('-r2SCAN')[0].split('_fallback')[0]
    
    return mp_id


def plot_hull_comparison(hull_comparison_data, output_dir):
    """
    Generate hull comparison plots from hull_comparison.json.
    
    Creates:
        - hull_comparison_scatter.png
        - hull_comparison_residuals.png
    """
    print("\nGenerating hull comparison plots...")
    
    matched = hull_comparison_data.get('matched_structures', [])
    stats = hull_comparison_data.get('summary', {})
    
    if not matched:
        print("  ERROR: No matched structures found in hull_comparison.json")
        return
    
    mattersim_vals = np.array([d['mattersim_e_hull'] for d in matched])
    dft_vals = np.array([d['dft_e_hull'] for d in matched])
    
    # ===== Scatter Plot =====
    fig, ax = plt.subplots(figsize=(18, 12))
    
    # Calculate point density for color mapping
    x = dft_vals
    y = mattersim_vals
    xy = np.vstack([x, y])
    z = gaussian_kde(xy)(xy)
    z = z * len(x)
    
    # Create custom colormap
    colors_list = ['cyan', 'dodgerblue', 'black']
    n_bins = 100
    cmap = LinearSegmentedColormap.from_list("density", colors_list, N=n_bins)
    
    # Sort points by density so densest are plotted last
    idx = z.argsort()
    x_sorted, y_sorted, z_sorted = x[idx], y[idx], z[idx]
    
    # Determine plot range
    all_vals = np.concatenate([mattersim_vals, dft_vals])
    val_min, val_max = all_vals.min(), all_vals.max()
    margin = (val_max - val_min) * 0.05
    plot_min, plot_max = val_min - margin, val_max + margin
    
    # Create scatter plot with density-based coloring
    scatter = ax.scatter(x_sorted, y_sorted, c=z_sorted, cmap=cmap, 
                        norm=mpl.colors.LogNorm(), s=20, marker='s', 
                        edgecolors='none')
    
    # Add colorbar
    # cbar = plt.colorbar(scatter, ax=ax)
    
    # Perfect agreement line
    ax.plot([plot_min, plot_max], [plot_min, plot_max], 'r--', 
            linewidth=2, alpha=0.7, label='Perfect agreement (y=x)')
    
    # Stability threshold line
    threshold = stats.get('threshold', 0.1)
    ax.axhline(y=threshold, color='green', linestyle=':', linewidth=2, 
               alpha=0.6, label=f'Stability threshold ({threshold} eV/atom)')
    ax.axvline(x=threshold, color='green', linestyle=':', linewidth=2, alpha=0.6)
    
    # Labels and title
    ax.set_xlabel('VASP DFT E_hull (eV/atom)', fontsize=18, fontweight='bold')
    ax.set_ylabel('MatterSim E_hull (eV/atom)', fontsize=18, fontweight='bold')
    ax.set_title('MatterSim vs VASP E_Hull Comparison', fontsize=20, fontweight='bold')
    
    # Recalculate statistics from actual plotted data
    correlation = np.corrcoef(mattersim_vals, dft_vals)[0, 1]
    mae = np.mean(np.abs(mattersim_vals - dft_vals))
    
    # Statistics text box (simplified)
    stats_text = (
        f"N = {len(matched)}\n"
        f"R = {correlation:.4f}\n"
        f"MAE = {mae:.4f} eV/atom"
    )
    ax.text(0.05, 0.95, stats_text, transform=ax.transAxes, fontsize=14,
            verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
    
    # Grid and legend
    ax.grid(True, alpha=0.3, linestyle='--')
    ax.minorticks_on()
    ax.grid(True, which='minor', alpha=0.15, linestyle=':')
    ax.legend(loc='lower right', fontsize=14)
    
    # Equal aspect
    ax.set_aspect('equal', adjustable='box')
    ax.set_xlim(plot_min, plot_max)
    ax.set_ylim(plot_min, threshold)
    
    # Increase tick label font sizes
    ax.tick_params(axis='both', which='major', labelsize=14)
    
    plt.tight_layout()
    scatter_file = output_dir / "hull_comparison_scatter.png"
    plt.savefig(scatter_file, dpi=300, bbox_inches='tight')
    print(f"    {scatter_file.name}")
    plt.close()
    
    # ===== Residual Plot =====
    fig, ax = plt.subplots(figsize=(12, 12))
    
    residuals = mattersim_vals - dft_vals
    
    # Calculate point density for color mapping
    x_res = dft_vals
    y_res = residuals
    xy_res = np.vstack([x_res, y_res])
    z_res = gaussian_kde(xy_res)(xy_res)
    z_res = z_res * len(x_res)
    
    # Create custom colormap
    colors_list_res = ['lime', 'forestgreen', 'black']
    cmap_res = LinearSegmentedColormap.from_list("density_residual", colors_list_res, N=100)
    
    # Sort points by density
    idx_res = z_res.argsort()
    x_res_sorted, y_res_sorted, z_res_sorted = x_res[idx_res], y_res[idx_res], z_res[idx_res]
    
    # Create scatter plot with density-based coloring
    scatter_res = ax.scatter(x_res_sorted, y_res_sorted, c=z_res_sorted, cmap=cmap_res, 
                            norm=mpl.colors.LogNorm(), s=20, marker='s', 
                            edgecolors='none')
    
    # Add colorbar
    # cbar_res = plt.colorbar(scatter_res, ax=ax)
    
    # Reference lines
    ax.axhline(y=0, color='r', linestyle='--', linewidth=2, alpha=0.7, 
               label='Zero residual (perfect agreement)')
    
    # Mean residual
    mean_residual = np.mean(residuals)
    ax.axhline(y=mean_residual, color='orange', linestyle='-', linewidth=2, 
               alpha=0.7, label=f'Mean residual = {mean_residual:+.4f} eV/atom')
    
    # ±0.05 eV/atom bands
    ax.axhline(y=0.05, color='green', linestyle=':', linewidth=1.5, alpha=0.6, 
               label='±0.05 eV/atom')
    ax.axhline(y=-0.05, color='green', linestyle=':', linewidth=1.5, alpha=0.6)
    
    # Labels and title
    ax.set_xlabel('VASP DFT E_hull (eV/atom)', fontsize=18, fontweight='bold')
    ax.set_ylabel('Residual (MatterSim - VASP) (eV/atom)', fontsize=18, fontweight='bold')
    ax.set_title('Hull Energy Residuals vs VASP DFT', fontsize=20, fontweight='bold')
    
    # Set Y-axis range
    residual_range = max(abs(residuals.min()), abs(residuals.max()))
    y_limit = max(0.2, residual_range * 1.5)
    ax.set_ylim(-y_limit, y_limit)
    
    # Increase tick label font sizes
    ax.tick_params(axis='both', which='major', labelsize=14)
    
    # Grid and legend
    ax.grid(True, alpha=0.3, linestyle='--')
    ax.minorticks_on()
    ax.grid(True, which='minor', alpha=0.15, linestyle=':')
    ax.legend(loc='best', fontsize=14)
    
    plt.tight_layout()
    residual_file = output_dir / "hull_comparison_residuals.png"
    plt.savefig(residual_file, dpi=300, bbox_inches='tight')
    print(f"    {residual_file.name}")
    plt.close()


def plot_generated_structures(prescreen_data, dft_results_data, output_dir, outlier_threshold=0.5):
    """
    Generate generated structures comparison plots.
    
    Creates:
        - generated_structures_comparison_scatter.png
        - generated_structures_comparison_residuals.png
    """
    print("\nGenerating generated structures comparison plots...")
    
    # Extract MatterSim energies for structures that passed prescreening
    ms_energies = {}
    for result in prescreen_data.get('results', []):
        if result.get('passed_prescreening', False) and result.get('mattersim_energy_per_atom') is not None:
            struct_id = result['structure_id']
            ms_energies[struct_id] = result['mattersim_energy_per_atom']
    
    # Extract VASP energies and E_hull from DFT results
    vasp_energies = {}
    dft_e_hull_lookup = {}
    
    for result in dft_results_data.get('results', []):
        struct_id = result['structure_id']
        vasp_e = result.get('vasp_energy_per_atom')
        dft_e_hull = result.get('energy_above_hull')
        
        if vasp_e is not None:
            vasp_energies[struct_id] = vasp_e
            if dft_e_hull is not None:
                dft_e_hull_lookup[struct_id] = dft_e_hull
    
    # Match structures
    matched = []
    for struct_id in ms_energies.keys():
        # Skip if no E_hull (ensures exact match with hull_comparison)
        if struct_id not in dft_e_hull_lookup or struct_id not in vasp_energies:
            continue
        
        ms_e = ms_energies[struct_id]
        vasp_e = vasp_energies[struct_id]
        
        matched.append({
            'structure_id': struct_id,
            'mattersim_energy_per_atom': ms_e,
            'vasp_energy_per_atom': vasp_e,
            'energy_diff': ms_e - vasp_e,
            'dft_e_hull': dft_e_hull_lookup[struct_id]
        })
    
    # Filter outliers based on DFT E_hull threshold
    matched_filtered = []
    skipped_outliers = []
    
    for entry in matched:
        dft_e_hull = entry['dft_e_hull']
        if dft_e_hull > outlier_threshold:
            skipped_outliers.append(entry)
            continue
        matched_filtered.append(entry)
    
    print(f"  Total matched: {len(matched)}")
    print(f"  After outlier filtering: {len(matched_filtered)} (excluded {len(skipped_outliers)})")
    
    if not matched_filtered:
        print("  ERROR: No structures after filtering")
        return
    
    # Calculate statistics
    diffs = np.array([m['energy_diff'] for m in matched_filtered])
    ms_vals = np.array([m['mattersim_energy_per_atom'] for m in matched_filtered])
    vasp_vals = np.array([m['vasp_energy_per_atom'] for m in matched_filtered])
    
    stats = {
        'n_structures': len(matched_filtered),
        'n_outliers_filtered': len(skipped_outliers),
        'mae': np.mean(np.abs(diffs)),
        'rmse': np.sqrt(np.mean(diffs**2)),
        'mean_diff': np.mean(diffs),
        'std_diff': np.std(diffs),
        'correlation': np.corrcoef(ms_vals, vasp_vals)[0, 1]
    }
    
    # ===== Scatter Plot =====
    fig, ax = plt.subplots(figsize=(12, 12))
    
    # Calculate point density for color mapping
    x = vasp_vals
    y = ms_vals
    xy = np.vstack([x, y])
    z = gaussian_kde(xy)(xy)
    z = z * len(x)
    
    # Create custom colormap
    colors_list = ['cyan', 'dodgerblue', 'black']
    n_bins = 100
    cmap = LinearSegmentedColormap.from_list("density", colors_list, N=n_bins)
    
    # Sort points by density so densest are plotted last
    idx = z.argsort()
    x_sorted, y_sorted, z_sorted = x[idx], y[idx], z[idx]
    
    # Determine plot range
    all_vals = np.concatenate([ms_vals, vasp_vals])
    val_min, val_max = all_vals.min(), all_vals.max()
    margin = (val_max - val_min) * 0.05
    plot_min, plot_max = val_min - margin, val_max + margin
    
    # Create scatter plot with density-based coloring
    scatter = ax.scatter(x_sorted, y_sorted, c=z_sorted, cmap=cmap, 
                        norm=mpl.colors.LogNorm(), s=20, marker='s', 
                        edgecolors='none')
    
    # Add colorbar
    # cbar = plt.colorbar(scatter, ax=ax)
    
    # Perfect agreement line
    ax.plot([plot_min, plot_max], [plot_min, plot_max], 'r--',
            linewidth=2, alpha=0.7, label='Perfect agreement (y=x)')
    
    # Labels
    ax.set_xlabel('VASP-DFT Energy per Atom (eV)', fontsize=18, fontweight='bold')
    ax.set_ylabel('MatterSim Energy per Atom (eV)', fontsize=18, fontweight='bold')
    ax.set_title('Generated Structures: MatterSim vs VASP-DFT', fontsize=20, fontweight='bold')
    
    # Statistics text (simplified, recalculated from plotted data)
    stats_text = (
        f"N = {stats['n_structures']}\n"
        f"R = {stats['correlation']:.4f}\n"
        f"MAE = {stats['mae']:.4f} eV/atom"
    )
    ax.text(0.05, 0.95, stats_text, transform=ax.transAxes, fontsize=14,
            verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
    
    # Grid and legend
    ax.grid(True, alpha=0.3, linestyle='--')
    ax.legend(loc='lower right', fontsize=14)
    ax.set_aspect('equal', adjustable='box')
    ax.set_xlim(plot_min, plot_max)
    ax.set_ylim(plot_min, plot_max)
    
    # Increase tick label font sizes
    ax.tick_params(axis='both', which='major', labelsize=14)
    
    plt.tight_layout()
    scatter_file = output_dir / "generated_structures_comparison_scatter.png"
    plt.savefig(scatter_file, dpi=300, bbox_inches='tight')
    print(f"    {scatter_file.name}")
    plt.close()
    
    # ===== Residual Plot =====
    fig, ax = plt.subplots(figsize=(12, 12))
    
    residuals = ms_vals - vasp_vals
    
    # Calculate point density for color mapping
    x_res = vasp_vals
    y_res = residuals
    xy_res = np.vstack([x_res, y_res])
    z_res = gaussian_kde(xy_res)(xy_res)
    z_res = z_res * len(x_res)
    
    # Create custom colormap
    colors_list_res = ['lime', 'forestgreen', 'black']
    cmap_res = LinearSegmentedColormap.from_list("density_residual", colors_list_res, N=100)
    
    # Sort points by density
    idx_res = z_res.argsort()
    x_res_sorted, y_res_sorted, z_res_sorted = x_res[idx_res], y_res[idx_res], z_res[idx_res]
    
    # Create scatter plot with density-based coloring
    scatter_res = ax.scatter(x_res_sorted, y_res_sorted, c=z_res_sorted, cmap=cmap_res, 
                            norm=mpl.colors.LogNorm(), s=20, marker='s', 
                            edgecolors='none')
    
    # Add colorbar
    # cbar_res = plt.colorbar(scatter_res, ax=ax)
    
    ax.axhline(y=0, color='r', linestyle='--', linewidth=2, alpha=0.7,
              label='Zero residual')
    ax.axhline(y=stats['mean_diff'], color='orange', linestyle='-',
              linewidth=2, alpha=0.7,
              label=f'Mean = {stats["mean_diff"]:+.4f} eV/atom')
    
    # Labels and title
    ax.set_xlabel('VASP-DFT Energy per Atom (eV)', fontsize=18, fontweight='bold')
    ax.set_ylabel('Residual (MatterSim - VASP) (eV/atom)', fontsize=18, fontweight='bold')
    ax.set_title('Generated Structures: Energy Residuals', fontsize=20, fontweight='bold')
    
    # Increase tick label font sizes
    ax.tick_params(axis='both', which='major', labelsize=14)
    
    ax.grid(True, alpha=0.3, linestyle='--')
    ax.legend(loc='best', fontsize=14)
    
    plt.tight_layout()
    residual_file = output_dir / "generated_structures_comparison_residuals.png"
    plt.savefig(residual_file, dpi=300, bbox_inches='tight')
    print(f"    {residual_file.name}")
    plt.close()


def plot_mp_phases(mp_mattersim_cache, mp_dft_cache, output_dir):
    """
    Generate MP phases comparison plots.
    
    Creates:
        - mp_phases_comparison_scatter.png
        - mp_phases_comparison_residuals.png
    """
    print("\nGenerating MP phases comparison plots...")
    
    # Parse MatterSim cache
    ms_by_mpid = {}
    for item in mp_mattersim_cache:
        mp_id = extract_mp_id(item['entry_id'])
        ms_by_mpid[mp_id] = {
            'energy': item['energy'],
            'composition': Composition(item['composition'])
        }
    
    # Parse DFT cache
    dft_by_mpid = {}
    for item in mp_dft_cache:
        mp_id = extract_mp_id(item['entry_id'])
        dft_by_mpid[mp_id] = {
            'energy': item['energy'],
            'composition': Composition(item['composition'])
        }
    
    # Match entries
    common_ids = set(ms_by_mpid.keys()) & set(dft_by_mpid.keys())
    
    print(f"  MatterSim cache: {len(ms_by_mpid)} MP IDs")
    print(f"  DFT cache: {len(dft_by_mpid)} MP IDs")
    print(f"  Common: {len(common_ids)} MP IDs")
    
    if not common_ids:
        print("  ERROR: No common MP IDs found")
        return
    
    # Compare energies
    matched = []
    
    for mp_id in sorted(common_ids):
        ms_data = ms_by_mpid[mp_id]
        dft_data = dft_by_mpid[mp_id]
        
        # Total energies
        ms_energy = ms_data['energy']
        dft_energy = dft_data['energy']
        
        # Compute per-atom energies
        ms_comp = ms_data['composition']
        dft_comp = dft_data['composition']
        
        ms_natoms = ms_comp.num_atoms
        dft_natoms = dft_comp.num_atoms
        
        ms_energy_per_atom = ms_energy / ms_natoms
        dft_energy_per_atom = dft_energy / dft_natoms
        
        matched.append({
            'mp_id': mp_id,
            'mattersim_energy_per_atom': ms_energy_per_atom,
            'dft_energy_per_atom': dft_energy_per_atom,
            'energy_diff': ms_energy_per_atom - dft_energy_per_atom
        })
    
    # Calculate statistics
    diffs = np.array([m['energy_diff'] for m in matched])
    ms_per_atom = np.array([m['mattersim_energy_per_atom'] for m in matched])
    dft_per_atom = np.array([m['dft_energy_per_atom'] for m in matched])
    
    stats = {
        'n_structures': len(matched),
        'mae': np.mean(np.abs(diffs)),
        'rmse': np.sqrt(np.mean(diffs**2)),
        'mean_diff': np.mean(diffs),
        'std_diff': np.std(diffs),
        'correlation': np.corrcoef(ms_per_atom, dft_per_atom)[0, 1]
    }
    
    # ===== Scatter Plot =====
    fig, ax = plt.subplots(figsize=(12, 12))
    
    ax.scatter(dft_per_atom, ms_per_atom, alpha=0.6, s=50, 
              c='forestgreen', edgecolors='none')
    
    # Perfect agreement line
    all_vals = np.concatenate([ms_per_atom, dft_per_atom])
    val_min, val_max = all_vals.min(), all_vals.max()
    margin = (val_max - val_min) * 0.05
    plot_min, plot_max = val_min - margin, val_max + margin
    
    ax.plot([plot_min, plot_max], [plot_min, plot_max], 'r--', 
            linewidth=2, alpha=0.7, label='Perfect agreement (y=x)')
    
    # Labels
    ax.set_xlabel('MP Raw DFT Energy per Atom (eV)', fontsize=18, fontweight='bold')
    ax.set_ylabel('MatterSim Energy per Atom (eV)', fontsize=18, fontweight='bold')
    ax.set_title('MP On-Hull Phases: MatterSim vs MP Raw DFT', fontsize=20, fontweight='bold')
    
    # Statistics text (simplified, recalculated from plotted data)
    stats_text = (
        f"N = {stats['n_structures']}\n"
        f"R = {stats['correlation']:.4f}\n"
        f"MAE = {stats['mae']:.4f} eV/atom"
    )
    ax.text(0.05, 0.95, stats_text, transform=ax.transAxes, fontsize=14,
            verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
    
    # Grid and legend
    ax.grid(True, alpha=0.3, linestyle='--')
    ax.legend(loc='lower right', fontsize=14)
    ax.set_aspect('equal', adjustable='box')
    ax.set_xlim(plot_min, plot_max)
    ax.set_ylim(plot_min, plot_max)
    
    # Increase tick label font sizes
    ax.tick_params(axis='both', which='major', labelsize=14)
    
    plt.tight_layout()
    scatter_file = output_dir / "mp_phases_comparison_scatter.png"
    plt.savefig(scatter_file, dpi=300, bbox_inches='tight')
    print(f"    {scatter_file.name}")
    plt.close()
    
    # ===== Residual Plot =====
    fig, ax = plt.subplots(figsize=(12, 12))
    
    residuals = ms_per_atom - dft_per_atom
    
    ax.scatter(dft_per_atom, residuals, alpha=0.6, s=50,
              c='forestgreen', edgecolors='none')
    
    ax.axhline(y=0, color='r', linestyle='--', linewidth=2, alpha=0.7,
              label='Zero residual')
    ax.axhline(y=stats['mean_diff'], color='orange', linestyle='-',
              linewidth=2, alpha=0.7, 
              label=f'Mean = {stats["mean_diff"]:+.4f} eV/atom')
    
    ax.set_xlabel('MP Raw DFT Energy per Atom (eV)', fontsize=18, fontweight='bold')
    ax.set_ylabel('Residual (MatterSim - MP DFT) (eV/atom)', fontsize=18, fontweight='bold')
    ax.set_title('MP On-Hull Phases: Energy Residuals', fontsize=20, fontweight='bold')
    
    # Increase tick label font sizes
    ax.tick_params(axis='both', which='major', labelsize=14)
    
    ax.grid(True, alpha=0.3, linestyle='--')
    ax.legend(loc='best', fontsize=14)
    
    plt.tight_layout()
    residual_file = output_dir / "mp_phases_comparison_residuals.png"
    plt.savefig(residual_file, dpi=300, bbox_inches='tight')
    print(f"    {residual_file.name}")
    plt.close()


def main():
    parser = argparse.ArgumentParser(
        description="Generate energy comparison plots from pre-computed JSON results",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 e_hull_energy_plot.py --results-dir Bin-Ele-HT/prescreen_results
  python3 e_hull_energy_plot.py --results-dir Ter-Ele-HT/prescreen_results
  python3 e_hull_energy_plot.py --results-dir Bin-Ele-HT/prescreen_results --outlier-threshold 0.3
        """
    )
    parser.add_argument(
        '--results-dir',
        type=str,
        required=True,
        help="Directory containing JSON result files"
    )
    parser.add_argument(
        '--output-dir',
        type=str,
        default=None,
        help="Output directory for plots (default: same as results-dir)"
    )
    parser.add_argument(
        '--outlier-threshold',
        type=float,
        default=0.2,
        help="DFT E_hull outlier threshold for plot filtering (eV/atom, default: 0.2)"
    )
    
    args = parser.parse_args()
    
    results_dir = Path(args.results_dir).expanduser()
    output_dir = Path(args.output_dir).expanduser() if args.output_dir else results_dir
    output_dir.mkdir(parents=True, exist_ok=True)
    
    print("="*70)
    print("Energy Comparison Plot Generator")
    print("="*70)
    print(f"Results directory: {results_dir}")
    print(f"Output directory: {output_dir}")
    print(f"Outlier threshold: {args.outlier_threshold} eV/atom")
    print("="*70)
    
    # Check for required JSON files
    required_files = {
        'hull_comparison': results_dir / "hull_comparison.json",
        'prescreening': results_dir / "prescreening_stability.json",
        'dft_results': results_dir / "dft_stability_results.json",
        'mp_mattersim': results_dir / "mp_mattersim.json",
        'mp_vaspdft': results_dir / "mp_vaspdft.json"
    }
    
    missing_files = []
    for name, path in required_files.items():
        if not path.exists():
            missing_files.append(f"{name}: {path}")
    
    if missing_files:
        print("\nERROR: Missing required JSON files:")
        for missing in missing_files:
            print(f"  - {missing}")
        print("\nPlease ensure all JSON files are present in the results directory.")
        return 1
    
    print("\nLoading JSON files...")
    
    # Load all JSON files
    hull_comparison_data = load_json_file(required_files['hull_comparison'])
    prescreen_data = load_json_file(required_files['prescreening'])
    dft_results_data = load_json_file(required_files['dft_results'])
    mp_mattersim_cache = load_json_file(required_files['mp_mattersim'])
    mp_dft_cache = load_json_file(required_files['mp_vaspdft'])
    
    # Check if all files loaded successfully
    if not all([hull_comparison_data, prescreen_data, dft_results_data, 
                mp_mattersim_cache, mp_dft_cache]):
        print("\nERROR: Failed to load one or more JSON files")
        return 1
    
    print("\n" + "="*70)
    print("Generating Plots")
    print("="*70)
    
    # Use outlier threshold from hull_comparison.json if available (for consistency)
    # Otherwise use command-line argument
    hull_outlier_threshold = hull_comparison_data.get('summary', {}).get('outlier_threshold')
    if hull_outlier_threshold is not None and args.outlier_threshold == 0.2:
        # User didn't specify custom threshold, use the one from hull_comparison
        outlier_threshold_to_use = hull_outlier_threshold
        print(f"\nUsing outlier threshold from hull_comparison.json: {outlier_threshold_to_use} eV/atom")
    else:
        # User specified custom threshold, use it
        outlier_threshold_to_use = args.outlier_threshold
        if hull_outlier_threshold is not None and hull_outlier_threshold != args.outlier_threshold:
            print(f"\nUsing custom outlier threshold {args.outlier_threshold} eV/atom")
            print(f"         Original hull_comparison used {hull_outlier_threshold} eV/atom")
            print(f"         This may cause structure counts to differ from original plots")
    
    # Generate all plots
    try:
        # 1. Hull comparison plots (scatter + residuals)
        plot_hull_comparison(hull_comparison_data, output_dir)
        
        # 2. Generated structures comparison plots (scatter + residuals)
        plot_generated_structures(prescreen_data, dft_results_data, output_dir, 
                                 outlier_threshold=outlier_threshold_to_use)
        
        # 3. MP phases comparison plots (scatter + residuals)
        plot_mp_phases(mp_mattersim_cache, mp_dft_cache, output_dir)
        
    except Exception as e:
        print(f"\nERROR during plot generation: {e}")
        import traceback
        traceback.print_exc()
        return 1
    
    # List generated plots
    print("\n" + "="*70)
    print("SUCCESS: All plots generated")
    print("="*70)
    print(f"\nOutput directory: {output_dir}")
    print("\nGenerated plots:")
    
    plot_files = [
        "hull_comparison_scatter.png",
        "hull_comparison_residuals.png",
        "generated_structures_comparison_scatter.png",
        "generated_structures_comparison_residuals.png",
        "mp_phases_comparison_scatter.png",
        "mp_phases_comparison_residuals.png"
    ]
    
    for plot_file in plot_files:
        plot_path = output_dir / plot_file
        if plot_path.exists():
            print(f"    {plot_file}")
        else:
            print(f"  ✗ {plot_file} (not generated)")
    
    print("\n" + "="*70)
    print(f"\nTo view plots:")
    print(f"  cd {output_dir}")
    print(f"  open *.png")
    print("="*70 + "\n")
    
    return 0


if __name__ == '__main__':
    sys.exit(main())

