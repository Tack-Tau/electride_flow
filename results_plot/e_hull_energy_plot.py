#!/usr/bin/env python3
"""
Generate energy comparison plots from pre-computed JSON results.

This script reads JSON files generated by compute_dft_e_hull.py and compare_energy_methods.py
and regenerates all comparison plots without needing to re-parse VASP outputs.

Usage:
    python3 e_hull_energy_plot.py --results-dir <path_to_json_files>

Example:
    python3 e_hull_energy_plot.py --results-dir Bin-Ele-HT/prescreen_results
    python3 e_hull_energy_plot.py --results-dir Ter-Ele-HT/prescreen_results
"""

import os
import sys
import json
import argparse
import numpy as np
from pathlib import Path
from pymatgen.core import Composition

import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib.colors import LinearSegmentedColormap
from matplotlib.ticker import MultipleLocator
from scipy.stats import gaussian_kde

mpl.use('Agg')


def load_json_file(filepath):
    """Load JSON file safely."""
    filepath = Path(filepath)
    if not filepath.exists():
        print(f"ERROR: File not found: {filepath}")
        return None
    
    print(f"  Loading {filepath.name}...")
    with open(filepath, 'r') as f:
        return json.load(f)


def extract_mp_id(entry_id):
    """
    Extract base MP ID from various formats.
    
    Examples:
        'mp_mattersim_mp-12345' -> 'mp-12345'
        'mp-12345-GGA' -> 'mp-12345'
        'mp-12345' -> 'mp-12345'
    """
    if 'mp_mattersim_' in entry_id:
        mp_id = entry_id.split('mp_mattersim_')[1]
    else:
        mp_id = entry_id
    
    # Remove functional suffixes
    mp_id = mp_id.split('-GGA')[0].split('-r2SCAN')[0].split('_fallback')[0]
    
    return mp_id


def save_figure(fig, output_dir, filename_base):
    """Save figure in both PNG and PDF formats."""
    png_file = output_dir / f"{filename_base}.png"
    pdf_file = output_dir / f"{filename_base}.pdf"
    
    fig.savefig(png_file, dpi=300)
    fig.savefig(pdf_file)
    
    print(f"    {png_file.name}")
    print(f"    {pdf_file.name}")


def plot_hull_energy_comparison(hull_comparison_data, prescreen_data, dft_results_data, output_dir, outlier_threshold=0.5):
    """
    Generate combined hull energy comparison plots.
    
    Creates:
        - hull_energy_comparison_scatter.png/.pdf (hull comparison + generated structures scatter)
        - hull_energy_comparison_residuals.png/.pdf (hull comparison + generated structures residuals)
    """
    print("\nGenerating combined hull energy comparison plots...")
    
    # ===== DETERMINE SYSTEM TYPE (BINARY OR TERNARY) =====
    # Read composition from first structure to determine element count
    system_type = "binary"  # default
    
    # Try to get composition from hull_comparison data
    matched_hull = hull_comparison_data.get('matched_structures', [])
    if matched_hull:
        first_comp = Composition(matched_hull[0].get('composition', ''))
        n_elements = len(first_comp.elements)
        system_type = "ternary" if n_elements == 3 else "binary"
    else:
        # Try prescreening data
        prescreen_results = prescreen_data.get('results', [])
        if prescreen_results:
            first_comp = Composition(prescreen_results[0].get('composition', ''))
            n_elements = len(first_comp.elements)
            system_type = "ternary" if n_elements == 3 else "binary"
    
    print(f"  Detected system type: {system_type}")
    
    # ===== PREPARE DATA FOR HULL COMPARISON =====
    stats_hull = hull_comparison_data.get('summary', {})
    
    if not matched_hull:
        print("  ERROR: No matched structures found in hull_comparison.json")
        return
    
    mattersim_vals_hull = np.array([d['mattersim_e_hull'] for d in matched_hull])
    dft_vals_hull = np.array([d['dft_e_hull'] for d in matched_hull])
    
    # ===== PREPARE DATA FOR GENERATED STRUCTURES =====
    ms_energies = {}
    for result in prescreen_data.get('results', []):
        if result.get('passed_prescreening', False) and result.get('mattersim_energy_per_atom') is not None:
            struct_id = result['structure_id']
            ms_energies[struct_id] = result['mattersim_energy_per_atom']
    
    vasp_energies = {}
    dft_e_hull_lookup = {}
    
    for result in dft_results_data.get('results', []):
        struct_id = result['structure_id']
        vasp_e = result.get('vasp_energy_per_atom')
        dft_e_hull = result.get('energy_above_hull')
        
        if vasp_e is not None:
            vasp_energies[struct_id] = vasp_e
            if dft_e_hull is not None:
                dft_e_hull_lookup[struct_id] = dft_e_hull
    
    matched_gen = []
    for struct_id in ms_energies.keys():
        if struct_id not in dft_e_hull_lookup or struct_id not in vasp_energies:
            continue
        
        ms_e = ms_energies[struct_id]
        vasp_e = vasp_energies[struct_id]
        
        matched_gen.append({
            'structure_id': struct_id,
            'mattersim_energy_per_atom': ms_e,
            'vasp_energy_per_atom': vasp_e,
            'energy_diff': ms_e - vasp_e,
            'dft_e_hull': dft_e_hull_lookup[struct_id]
        })
    
    matched_gen_filtered = [entry for entry in matched_gen if entry['dft_e_hull'] <= outlier_threshold]
    
    ms_vals_gen = np.array([m['mattersim_energy_per_atom'] for m in matched_gen_filtered])
    vasp_vals_gen = np.array([m['vasp_energy_per_atom'] for m in matched_gen_filtered])
    
    # ===========================================================================================
    # COMBINED SCATTER PLOT: Hull E_hull (left) + Generated Structures (right)
    # ===========================================================================================
    # Use FIXED figure dimensions and subplot positions for consistent LaTeX embedding
    fig = plt.figure(figsize=(28, 12))
    
    # Add single title at the top
    fig.suptitle(f'Energy comparison for {system_type} structures', fontsize=38, fontweight='bold', y=0.98)
    
    # Calculate data ranges for axis limits
    # LEFT plot data
    x1 = dft_vals_hull
    y1 = mattersim_vals_hull
    all_vals1 = np.concatenate([mattersim_vals_hull, dft_vals_hull])
    val_min1, val_max1 = all_vals1.min(), all_vals1.max()
    margin1 = (val_max1 - val_min1) * 0.05
    plot_min1, plot_max1 = val_min1 - margin1, val_max1 + margin1
    threshold = stats_hull.get('threshold', 0.1)
    
    # RIGHT plot data
    x2 = vasp_vals_gen
    y2 = ms_vals_gen
    all_vals2 = np.concatenate([ms_vals_gen, vasp_vals_gen])
    val_min2, val_max2 = all_vals2.min(), all_vals2.max()
    margin2 = (val_max2 - val_min2) * 0.05
    plot_min2, plot_max2 = val_min2 - margin2, val_max2 + margin2
    
    # FIXED subplot positions [left, bottom, width, height]
    ax1 = fig.add_axes([0.47, 0.1, 0.515, 0.82])  # Hull comparison
    ax2 = fig.add_axes([0.05, 0.1, 0.343, 0.82])  # Energy comparison
    
    # ===== RIGHT: Hull Comparison Scatter =====
    xy1 = np.vstack([x1, y1])
    z1 = gaussian_kde(xy1)(xy1)
    z1 = z1 * len(x1)
    
    colors_list = ['cyan', 'dodgerblue', 'black']
    cmap = LinearSegmentedColormap.from_list("density", colors_list, N=100)
    
    idx1 = z1.argsort()
    x1_sorted, y1_sorted, z1_sorted = x1[idx1], y1[idx1], z1[idx1]
    
    scatter1 = ax1.scatter(x1_sorted, y1_sorted, c=z1_sorted, cmap=cmap, 
                          norm=mpl.colors.LogNorm(), s=70, marker='s', 
                          edgecolors='none')
    
    ax1.plot([plot_min1, plot_max1], [plot_min1, plot_max1], 'r--', 
            linewidth=2.5, alpha=0.7, label='Perfect agreement')
    ax1.axhline(y=threshold, color='green', linestyle=':', linewidth=2, alpha=0.6)
    ax1.axvline(x=threshold, color='green', linestyle=':', linewidth=2, alpha=0.6)
    
    ax1.set_xlabel(r'E$_{\mathrm{ref\text{-}hull\text{-}DFT}}$ (eV/atom)', fontsize=34, fontweight='bold')
    ax1.set_ylabel(r'E$_{\mathrm{ref\text{-}hull\text{-}MLP}}$ (eV/atom)', fontsize=34, fontweight='bold')
    
    correlation1 = np.corrcoef(mattersim_vals_hull, dft_vals_hull)[0, 1]
    mae1 = np.mean(np.abs(mattersim_vals_hull - dft_vals_hull))
    
    stats_text1 = (
        # f"N = {len(matched_hull)}\n"
        f"R = {correlation1:.4f}\n"
        f"MAE = {mae1:.3f} eV/atom"
    )
    ax1.text(0.02, 0.98, stats_text1, transform=ax1.transAxes, fontsize=32,
            verticalalignment='top', bbox=dict(boxstyle='round', facecolor='white', alpha=0.0))
    
    ax1.grid(True, alpha=0.3, linestyle='--')
    ax1.minorticks_on()
    ax1.grid(True, which='minor', alpha=0.15, linestyle=':')
    ax1.legend(loc='lower right', fontsize=32, framealpha=0.0, edgecolor='none')
    
    ax1.set_xlim(plot_min1, plot_max1)
    ax1.set_ylim(plot_min1, threshold)
    ax1.tick_params(axis='both', which='major', labelsize=28)
    
    # ===== LEFT: Energy Comparison Scatter =====
    xy2 = np.vstack([x2, y2])
    z2 = gaussian_kde(xy2)(xy2)
    z2 = z2 * len(x2)
    
    idx2 = z2.argsort()
    x2_sorted, y2_sorted, z2_sorted = x2[idx2], y2[idx2], z2[idx2]
    
    scatter2 = ax2.scatter(x2_sorted, y2_sorted, c=z2_sorted, cmap=cmap, 
                          norm=mpl.colors.LogNorm(), s=70, marker='s', 
                          edgecolors='none')
    
    ax2.plot([plot_min2, plot_max2], [plot_min2, plot_max2], 'r--',
            linewidth=2.5, alpha=0.7, label='Perfect agreement')
    
    ax2.set_xlabel(r'E$_{\mathrm{abs\text{-}DFT}}$ (eV/atom)', fontsize=34, fontweight='bold')
    ax2.set_ylabel(r'E$_{\mathrm{abs\text{-}MLP}}$ (eV/atom)', fontsize=34, fontweight='bold')
    
    correlation2 = np.corrcoef(ms_vals_gen, vasp_vals_gen)[0, 1]
    mae2 = np.mean(np.abs(ms_vals_gen - vasp_vals_gen))
    
    stats_text2 = (
        # f"N = {len(matched_gen_filtered)}\n"
        f"R = {correlation2:.4f}\n"
        f"MAE = {mae2:.3f} eV/atom"
    )
    ax2.text(0.02, 0.98, stats_text2, transform=ax2.transAxes, fontsize=32,
            verticalalignment='top', bbox=dict(boxstyle='round', facecolor='white', alpha=0.0))
    
    ax2.grid(True, alpha=0.3, linestyle='--')
    ax2.legend(loc='lower right', fontsize=32, framealpha=0.0, edgecolor='none')
    ax2.set_xlim(plot_min2, plot_max2)
    ax2.set_ylim(plot_min2, plot_max2)
    
    # Set custom tick spacing
    ax2.xaxis.set_major_locator(MultipleLocator(2.0))
    ax2.xaxis.set_minor_locator(MultipleLocator(0.5))
    ax2.yaxis.set_major_locator(MultipleLocator(2.0))
    ax2.yaxis.set_minor_locator(MultipleLocator(0.5))
    
    ax2.tick_params(axis='both', which='major', labelsize=28)
    ax2.tick_params(axis='both', which='minor', length=4)
    ax2.minorticks_on()
    ax2.grid(True, which='minor', alpha=0.15, linestyle=':')
    
    save_figure(fig, output_dir, "hull_energy_comparison_scatter")
    plt.close()
    
    # ===========================================================================================
    # COMBINED RESIDUAL PLOT: Hull Residuals (left) + Generated Structures Residuals (right)
    # ===========================================================================================
    # Use FIXED figure dimensions and subplot positions for consistent LaTeX embedding
    fig = plt.figure(figsize=(24, 12))
    
    # Add single title at the top
    fig.suptitle(f'Energy comparison for {system_type} structures', fontsize=32, fontweight='bold', y=0.98)
    
    # FIXED subplot positions [left, bottom, width, height]
    ax1 = fig.add_axes([0.06, 0.1, 0.425, 0.82])
    ax2 = fig.add_axes([0.555, 0.1, 0.425, 0.82])
    
    # ===== LEFT: Hull Comparison Residuals =====
    residuals1 = mattersim_vals_hull - dft_vals_hull
    
    x_res1 = dft_vals_hull
    y_res1 = residuals1
    xy_res1 = np.vstack([x_res1, y_res1])
    z_res1 = gaussian_kde(xy_res1)(xy_res1)
    z_res1 = z_res1 * len(x_res1)
    
    colors_list_res = ['lime', 'forestgreen', 'black']
    cmap_res = LinearSegmentedColormap.from_list("density_residual", colors_list_res, N=100)
    
    idx_res1 = z_res1.argsort()
    x_res1_sorted, y_res1_sorted, z_res1_sorted = x_res1[idx_res1], y_res1[idx_res1], z_res1[idx_res1]
    
    scatter_res1 = ax1.scatter(x_res1_sorted, y_res1_sorted, c=z_res1_sorted, cmap=cmap_res, 
                              norm=mpl.colors.LogNorm(), s=50, marker='s', 
                              edgecolors='none')
    
    ax1.axhline(y=0, color='r', linestyle='--', linewidth=2.5, alpha=0.7, 
               label='Zero residual')
    
    mean_residual1 = np.mean(residuals1)
    ax1.axhline(y=mean_residual1, color='orange', linestyle='-', linewidth=2.5, 
               alpha=0.7, label=f'Mean = {mean_residual1:+.4f} eV/atom')
    
    ax1.axhline(y=0.05, color='green', linestyle=':', linewidth=1.5, alpha=0.6, 
               label='±0.05 eV/atom')
    ax1.axhline(y=-0.05, color='green', linestyle=':', linewidth=1.5, alpha=0.6)
    
    ax1.set_xlabel(r'E$_{\mathrm{ref\text{-}hull\text{-}DFT}}$ (eV/atom)', fontsize=26, fontweight='bold')
    ax1.set_ylabel(r'E$_{\mathrm{ref\text{-}hull\text{-}MLP}}$ - E$_{\mathrm{ref\text{-}hull\text{-}DFT}}$ (eV/atom)', fontsize=26, fontweight='bold')
    
    residual_range1 = max(abs(residuals1.min()), abs(residuals1.max()))
    y_limit1 = max(0.2, residual_range1 * 1.5)
    
    ax1.set_xlim(plot_min1, plot_max1)
    
    ax1.tick_params(axis='both', which='major', labelsize=22)
    ax1.grid(True, alpha=0.3, linestyle='--')
    ax1.minorticks_on()
    ax1.grid(True, which='minor', alpha=0.15, linestyle=':')
    ax1.legend(loc='lower right', fontsize=22, framealpha=0.0, edgecolor='none')
    
    # ===== RIGHT: Generated Structures Residuals =====
    residuals2 = ms_vals_gen - vasp_vals_gen
    
    x_res2 = vasp_vals_gen
    y_res2 = residuals2
    xy_res2 = np.vstack([x_res2, y_res2])
    z_res2 = gaussian_kde(xy_res2)(xy_res2)
    z_res2 = z_res2 * len(x_res2)
    
    idx_res2 = z_res2.argsort()
    x_res2_sorted, y_res2_sorted, z_res2_sorted = x_res2[idx_res2], y_res2[idx_res2], z_res2[idx_res2]
    
    scatter_res2 = ax2.scatter(x_res2_sorted, y_res2_sorted, c=z_res2_sorted, cmap=cmap_res, 
                              norm=mpl.colors.LogNorm(), s=50, marker='s', 
                              edgecolors='none')
    
    ax2.axhline(y=0, color='r', linestyle='--', linewidth=2.5, alpha=0.7,
              label='Zero residual')
    
    mean_residual2 = np.mean(residuals2)
    ax2.axhline(y=mean_residual2, color='orange', linestyle='-',
              linewidth=2.5, alpha=0.7,
              label=f'Mean = {mean_residual2:+.4f} eV/atom')
    
    ax2.set_xlabel(r'E$_{\mathrm{abs\text{-}DFT}}$ (eV/atom)', fontsize=26, fontweight='bold')
    ax2.set_ylabel(r'E$_{\mathrm{abs\text{-}MLP}}$ - E$_{\mathrm{abs\text{-}DFT}}$ (eV/atom)', fontsize=26, fontweight='bold')
    
    residual_range2 = max(abs(residuals2.min()), abs(residuals2.max()))
    y_limit2 = max(0.2, residual_range2 * 1.5)
    
    # Use the same y-limit for both plots for consistent height
    y_limit_combined = max(y_limit1, y_limit2)
    ax1.set_ylim(-y_limit_combined, y_limit_combined)
    ax2.set_ylim(-y_limit_combined, y_limit_combined)
    
    ax2.set_xlim(plot_min2, plot_max2)
    
    ax2.tick_params(axis='both', which='major', labelsize=22)
    ax2.grid(True, alpha=0.3, linestyle='--')
    ax2.legend(loc='lower right', fontsize=22, framealpha=0.0, edgecolor='none')
    
    save_figure(fig, output_dir, "hull_energy_comparison_residuals")
    plt.close()


def plot_mp_phases_combined(mp_mattersim_cache, mp_dft_cache, output_dir):
    """
    Generate combined MP phases comparison plot.
    
    Creates:
        - mp_phases_comparison.png/.pdf (scatter + residuals)
    """
    print("\nGenerating combined MP phases comparison plot...")
    
    # Parse MatterSim cache
    ms_by_mpid = {}
    for item in mp_mattersim_cache:
        mp_id = extract_mp_id(item['entry_id'])
        ms_by_mpid[mp_id] = {
            'energy': item['energy'],
            'composition': Composition(item['composition'])
        }
    
    # Parse DFT cache
    dft_by_mpid = {}
    for item in mp_dft_cache:
        mp_id = extract_mp_id(item['entry_id'])
        dft_by_mpid[mp_id] = {
            'energy': item['energy'],
            'composition': Composition(item['composition'])
        }
    
    # Match entries
    common_ids = set(ms_by_mpid.keys()) & set(dft_by_mpid.keys())
    
    print(f"  MatterSim cache: {len(ms_by_mpid)} MP IDs")
    print(f"  DFT cache: {len(dft_by_mpid)} MP IDs")
    print(f"  Common: {len(common_ids)} MP IDs")
    
    if not common_ids:
        print("  ERROR: No common MP IDs found")
        return
    
    # Compare energies
    matched = []
    
    for mp_id in sorted(common_ids):
        ms_data = ms_by_mpid[mp_id]
        dft_data = dft_by_mpid[mp_id]
        
        ms_energy = ms_data['energy']
        dft_energy = dft_data['energy']
        
        ms_comp = ms_data['composition']
        dft_comp = dft_data['composition']
        
        ms_natoms = ms_comp.num_atoms
        dft_natoms = dft_comp.num_atoms
        
        ms_energy_per_atom = ms_energy / ms_natoms
        dft_energy_per_atom = dft_energy / dft_natoms
        
        matched.append({
            'mp_id': mp_id,
            'mattersim_energy_per_atom': ms_energy_per_atom,
            'dft_energy_per_atom': dft_energy_per_atom,
            'energy_diff': ms_energy_per_atom - dft_energy_per_atom
        })
    
    # Calculate statistics
    diffs = np.array([m['energy_diff'] for m in matched])
    ms_per_atom = np.array([m['mattersim_energy_per_atom'] for m in matched])
    dft_per_atom = np.array([m['dft_energy_per_atom'] for m in matched])
    
    correlation = np.corrcoef(ms_per_atom, dft_per_atom)[0, 1]
    mae = np.mean(np.abs(diffs))
    
    # ===========================================================================================
    # COMBINED PLOT: MP Phases Scatter (left) + Residuals (right)
    # ===========================================================================================
    # Use FIXED figure dimensions and subplot positions for consistent LaTeX embedding
    fig = plt.figure(figsize=(24, 12))
    
    # Add single title at the top
    fig.suptitle('Energy comparison for MP reference phases', fontsize=32, fontweight='bold', y=0.98)
    
    # FIXED subplot positions [left, bottom, width, height]
    ax1 = fig.add_axes([0.06, 0.1, 0.425, 0.82])
    ax2 = fig.add_axes([0.555, 0.1, 0.425, 0.82])
    
    # ===== LEFT: Scatter Plot =====
    ax1.scatter(dft_per_atom, ms_per_atom, alpha=0.6, s=80, 
              c='forestgreen', edgecolors='none')
    
    all_vals = np.concatenate([ms_per_atom, dft_per_atom])
    val_min, val_max = all_vals.min(), all_vals.max()
    margin = (val_max - val_min) * 0.05
    plot_min, plot_max = val_min - margin, val_max + margin
    
    ax1.plot([plot_min, plot_max], [plot_min, plot_max], 'r--', 
            linewidth=2.5, alpha=0.7, label='Perfect agreement')
    
    ax1.set_xlabel(r'E$_{\mathrm{abs\text{-}DFT}}$ (eV/atom)', fontsize=26, fontweight='bold')
    ax1.set_ylabel(r'E$_{\mathrm{abs\text{-}MLP}}$ (eV/atom)', fontsize=26, fontweight='bold')
    
    stats_text = (
        # f"N = {len(matched)}\n"
        f"R = {correlation:.4f}\n"
        f"MAE = {mae:.3f} eV/atom"
    )
    ax1.text(0.02, 0.98, stats_text, transform=ax1.transAxes, fontsize=22,
            verticalalignment='top', bbox=dict(boxstyle='round', facecolor='white', alpha=0.0))
    
    ax1.grid(True, alpha=0.3, linestyle='--')
    ax1.legend(loc='lower right', fontsize=22, framealpha=0.0, edgecolor='none')
    ax1.set_xlim(plot_min, plot_max)
    ax1.set_ylim(plot_min, plot_max)
    ax1.set_aspect('equal', adjustable='box')
    ax1.tick_params(axis='both', which='major', labelsize=22)
    
    # ===== RIGHT: Residual Plot =====
    residuals = ms_per_atom - dft_per_atom
    mean_diff = np.mean(residuals)
    
    ax2.scatter(dft_per_atom, residuals, alpha=0.6, s=80,
              c='forestgreen', edgecolors='none')
    
    ax2.axhline(y=0, color='r', linestyle='--', linewidth=2.5, alpha=0.7,
              label='Zero residual')
    ax2.axhline(y=mean_diff, color='orange', linestyle='-',
              linewidth=2.5, alpha=0.7, 
              label=f'Mean = {mean_diff:+.4f} eV/atom')
    
    ax2.set_xlabel(r'E$_{\mathrm{abs\text{-}DFT}}$ (eV/atom)', fontsize=26, fontweight='bold')
    ax2.set_ylabel(r'E$_{\mathrm{abs\text{-}MLP}}$ - E$_{\mathrm{abs\text{-}DFT}}$ (eV/atom)', fontsize=26, fontweight='bold')
    
    ax2.tick_params(axis='both', which='major', labelsize=22)
    ax2.grid(True, alpha=0.3, linestyle='--')
    ax2.legend(loc='lower right', fontsize=22, framealpha=0.0, edgecolor='none')
    
    save_figure(fig, output_dir, "mp_phases_comparison")
    plt.close()


def main():
    parser = argparse.ArgumentParser(
        description="Generate energy comparison plots from pre-computed JSON results",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 e_hull_energy_plot.py --results-dir Bin-Ele-HT/prescreen_results
  python3 e_hull_energy_plot.py --results-dir Ter-Ele-HT/prescreen_results
  python3 e_hull_energy_plot.py --results-dir Bin-Ele-HT/prescreen_results --outlier-threshold 0.3
        """
    )
    parser.add_argument(
        '--results-dir',
        type=str,
        required=True,
        help="Directory containing JSON result files"
    )
    parser.add_argument(
        '--output-dir',
        type=str,
        default=None,
        help="Output directory for plots (default: same as results-dir)"
    )
    parser.add_argument(
        '--outlier-threshold',
        type=float,
        default=0.2,
        help="DFT E_hull outlier threshold for plot filtering (eV/atom, default: 0.2)"
    )
    
    args = parser.parse_args()
    
    results_dir = Path(args.results_dir).expanduser()
    output_dir = Path(args.output_dir).expanduser() if args.output_dir else results_dir
    output_dir.mkdir(parents=True, exist_ok=True)
    
    print("="*70)
    print("Energy Comparison Plot Generator")
    print("="*70)
    print(f"Results directory: {results_dir}")
    print(f"Output directory: {output_dir}")
    print(f"Outlier threshold: {args.outlier_threshold} eV/atom")
    print("="*70)
    
    # Check for required JSON files
    required_files = {
        'hull_comparison': results_dir / "hull_comparison.json",
        'prescreening': results_dir / "prescreening_stability.json",
        'dft_results': results_dir / "dft_stability_results.json",
        'mp_mattersim': results_dir / "mp_mattersim.json",
        'mp_vaspdft': results_dir / "mp_vaspdft.json"
    }
    
    missing_files = []
    for name, path in required_files.items():
        if not path.exists():
            missing_files.append(f"{name}: {path}")
    
    if missing_files:
        print("\nERROR: Missing required JSON files:")
        for missing in missing_files:
            print(f"  - {missing}")
        print("\nPlease ensure all JSON files are present in the results directory.")
        return 1
    
    print("\nLoading JSON files...")
    
    # Load all JSON files
    hull_comparison_data = load_json_file(required_files['hull_comparison'])
    prescreen_data = load_json_file(required_files['prescreening'])
    dft_results_data = load_json_file(required_files['dft_results'])
    mp_mattersim_cache = load_json_file(required_files['mp_mattersim'])
    mp_dft_cache = load_json_file(required_files['mp_vaspdft'])
    
    # Check if all files loaded successfully
    if not all([hull_comparison_data, prescreen_data, dft_results_data, 
                mp_mattersim_cache, mp_dft_cache]):
        print("\nERROR: Failed to load one or more JSON files")
        return 1
    
    print("\n" + "="*70)
    print("Generating Plots")
    print("="*70)
    
    # Use outlier threshold from hull_comparison.json if available (for consistency)
    hull_outlier_threshold = hull_comparison_data.get('summary', {}).get('outlier_threshold')
    if hull_outlier_threshold is not None and args.outlier_threshold == 0.2:
        outlier_threshold_to_use = hull_outlier_threshold
        print(f"\nUsing outlier threshold from hull_comparison.json: {outlier_threshold_to_use} eV/atom")
    else:
        outlier_threshold_to_use = args.outlier_threshold
        if hull_outlier_threshold is not None and hull_outlier_threshold != args.outlier_threshold:
            print(f"\nUsing custom outlier threshold {args.outlier_threshold} eV/atom")
            print(f"         Original hull_comparison used {hull_outlier_threshold} eV/atom")
            print(f"         This may cause structure counts to differ from original plots")
    
    # Generate all combined plots
    try:
        # 1. Combined hull energy comparison plots (scatter + residuals)
        plot_hull_energy_comparison(hull_comparison_data, prescreen_data, dft_results_data, 
                                    output_dir, outlier_threshold=outlier_threshold_to_use)
        
        # 2. Combined MP phases comparison plot (scatter + residuals)
        plot_mp_phases_combined(mp_mattersim_cache, mp_dft_cache, output_dir)
        
    except Exception as e:
        print(f"\nERROR during plot generation: {e}")
        import traceback
        traceback.print_exc()
        return 1
    
    # List generated plots
    print("\n" + "="*70)
    print("SUCCESS: All plots generated")
    print("="*70)
    print(f"\nOutput directory: {output_dir}")
    print("\nGenerated plots:")
    
    plot_files = [
        "hull_energy_comparison_scatter",
        "hull_energy_comparison_residuals",
        "mp_phases_comparison"
    ]
    
    for plot_base in plot_files:
        png_path = output_dir / f"{plot_base}.png"
        pdf_path = output_dir / f"{plot_base}.pdf"
        if png_path.exists() and pdf_path.exists():
            print(f"    {plot_base}.png")
            print(f"    {plot_base}.pdf")
        else:
            print(f"  ✗ {plot_base} (not generated)")
    
    print("\n" + "="*70)
    print(f"\nTo view plots:")
    print(f"  cd {output_dir}")
    print(f"  open *.png")
    print("="*70 + "\n")
    
    return 0


if __name__ == '__main__':
    sys.exit(main())

