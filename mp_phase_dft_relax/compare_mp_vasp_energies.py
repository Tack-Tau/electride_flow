#!/usr/bin/env python3
"""
Compare MP and VASP energies from MP phase relaxation workflow.

Compares:
- MP GGA-PBE DFT energies (from mp_vaspdft.json, generated by get_mp_struct.py or compute_dft_e_hull.py)
- VASP PBE DFT energies (from local VASP relaxation calculations)

Note: 
- No longer queries MP API directly (loads from JSON file)
- Ensures consistent energy source (same as used for structure download)
- Faster and more reproducible
"""

import os
import json
import argparse
import numpy as np
from pathlib import Path
from collections import defaultdict

from pymatgen.io.vasp.outputs import Vasprun
import matplotlib.pyplot as plt
import matplotlib as mpl

# Use non-interactive backend for cluster
mpl.use('Agg')


def load_workflow_db(db_path):
    """Load workflow database."""
    with open(db_path, 'r') as f:
        return json.load(f)


def load_mp_energies_from_json(json_path):
    """
    Load MP GGA-PBE DFT energies from JSON file.
    
    Expected to be generated by:
    - get_mp_struct.py (saves to mp_cache_structs/mp_vaspdft.json)
    - compute_dft_e_hull.py (saves to VASP_JOBS/mp_vaspdft.json)
    
    JSON format:
    [
        {
            "mp_id": "mp-12345",
            "entry_id": "mp-12345-GGA",
            "energy_per_atom": -5.12345,
            "chemsys": "Li-N",
            ...
        },
        ...
    ]
    
    Args:
        json_path: Path to mp_vaspdft.json file
    
    Returns:
        dict: {mp_id: energy_per_atom} using GGA-PBE functional
    """
    json_path = Path(json_path)
    
    if not json_path.exists():
        raise FileNotFoundError(
            f"MP energies file not found: {json_path}\n"
            f"Please generate it by running:\n"
            f"  1. get_mp_struct.py (saves to mp_cache_structs/mp_vaspdft.json), or\n"
            f"  2. compute_dft_e_hull.py (saves to VASP_JOBS/mp_vaspdft.json)"
        )
    
    print(f"\nLoading MP GGA-PBE DFT energies from: {json_path}")
    
    with open(json_path, 'r') as f:
        mp_data = json.load(f)
    
    mp_energies = {}
    for entry in mp_data:
        mp_id = entry.get('mp_id')
        energy_per_atom = entry.get('energy_per_atom')
        
        if mp_id and energy_per_atom is not None:
            mp_energies[mp_id] = float(energy_per_atom)
    
    print(f"  Loaded {len(mp_energies)} MP GGA-PBE energies (uncorrected, raw DFT)\n")
    
    return mp_energies


def check_electronic_convergence_outcar(outcar_path):
    """
    Check electronic convergence from OUTCAR file.
    
    For timed-out jobs, vasprun.xml is incomplete/corrupted. This function checks
    OUTCAR for "aborting loop because EDIFF is reached" marker, which indicates
    electronic SCF converged in at least one ionic step.
    
    Args:
        outcar_path: Path to OUTCAR file
    
    Returns:
        bool: True if electronic convergence was achieved
    """
    if not outcar_path.exists():
        return False
    
    try:
        with open(outcar_path, 'r') as f:
            content = f.read()
        return 'aborting loop because EDIFF is reached' in content
    except Exception:
        return False


def extract_energy_from_outcar(outcar_path):
    """
    Extract final energy from OUTCAR file.
    
    Used for timed-out jobs where vasprun.xml is incomplete. Searches for the
    last occurrence of "free energy TOTEN" or "energy without entropy".
    
    Args:
        outcar_path: Path to OUTCAR file
    
    Returns:
        float or None: Final energy (total, not per atom) or None if not found
    """
    if not outcar_path.exists():
        return None
    
    try:
        with open(outcar_path, 'r') as f:
            outcar_lines = f.readlines()
        
        final_energy = None
        for line in reversed(outcar_lines):
            if 'free  energy   TOTEN' in line or 'energy  without entropy' in line:
                try:
                    final_energy = float(line.split()[4])
                    break
                except (IndexError, ValueError):
                    continue
                
        return final_energy
    except Exception:
        return None


def check_vasp_convergence(relax_dir):
    """
    Check if VASP calculation truly converged by reading vasprun.xml.
    Falls back to OUTCAR if vasprun.xml is incomplete (timeout case).
    
    Args:
        relax_dir: Path to VASP relaxation directory
    
    Returns:
        bool: True if converged, False otherwise
    """
    relax_dir = Path(relax_dir)
    vasprun_path = relax_dir / 'vasprun.xml'
    
    # Try vasprun.xml first (standard case)
    if vasprun_path.exists():
        try:
            vr = Vasprun(str(vasprun_path), parse_dos=False, parse_eigen=False)
            return vr.converged
        except Exception:
            # vasprun.xml exists but corrupted - likely timeout
            pass
    
    # Fall back to OUTCAR (timeout case)
    outcar_path = relax_dir / 'OUTCAR'
    return check_electronic_convergence_outcar(outcar_path)


def analyze_energy_differences(db, mp_energies, check_convergence=True, outlier_threshold=0.5):
    """
    Analyze energy differences between MP (uncorrected DFT) and VASP.
    
    Args:
        db: Workflow database
        mp_energies: dict of {mp_id: energy_per_atom} from MP API
        check_convergence: If True, verify VASP convergence and exclude non-converged
        outlier_threshold: Energy difference threshold (eV/atom) for outlier detection
    
    Returns:
        dict: Statistics and structure lists
    """
    completed = {}
    skipped_not_converged = []
    skipped_no_energy = []
    recovered_from_outcar = []
    
    for mp_id, sdata in db['structures'].items():
        if sdata['state'] != 'COMPLETED':
            continue
        
        # Get VASP energy - try from database first, fall back to OUTCAR if None
        vasp_energy_per_atom = sdata.get('vasp_energy_per_atom')
        
        if vasp_energy_per_atom is None and sdata.get('relax_dir'):
            # Try to extract from OUTCAR (timeout case)
            relax_dir = Path(sdata['relax_dir'])
            outcar_path = relax_dir / 'OUTCAR'
            contcar_path = relax_dir / 'CONTCAR'
            
            if outcar_path.exists() and contcar_path.exists():
                try:
                    from pymatgen.core import Structure
                    
                    final_energy = extract_energy_from_outcar(outcar_path)
                    if final_energy is not None:
                        structure = Structure.from_file(str(contcar_path))
                        n_atoms = len(structure)
                        vasp_energy_per_atom = final_energy / n_atoms
                        sdata['vasp_energy_per_atom'] = vasp_energy_per_atom
                        recovered_from_outcar.append(mp_id)
                        print(f"  INFO: Recovered {mp_id} energy from OUTCAR (timed out)")
                except Exception as e:
                    print(f"  WARNING: Could not extract {mp_id} energy from OUTCAR: {e}")
        
        if vasp_energy_per_atom is None:
            skipped_no_energy.append(mp_id)
            continue
        
        # Get MP energy from fetched energies
        mp_e = mp_energies.get(mp_id)
        
        if mp_e is None:
            continue
        
        # Check VASP convergence if requested
        if check_convergence and sdata.get('relax_dir'):
            if not check_vasp_convergence(sdata['relax_dir']):
                skipped_not_converged.append(mp_id)
                print(f"  WARNING: Skipping {mp_id} - VASP calculation not converged")
                continue
        
            sdata['mp_energy_per_atom'] = mp_e  # Cache in sdata
            completed[mp_id] = sdata
    
    if not completed:
        return None
    
    # Report filtering results
    if recovered_from_outcar:
        print(f"\n  Recovered {len(recovered_from_outcar)} energies from OUTCAR (timed-out jobs)")
    if skipped_no_energy:
        print(f"  Skipped {len(skipped_no_energy)} structures (no VASP energy available)")
    if skipped_not_converged:
        print(f"  Filtered out {len(skipped_not_converged)} non-converged structures")
    
    # First pass: calculate all differences to detect outliers
    all_diffs = []
    for mp_id, sdata in completed.items():
        mp_e = sdata['mp_energy_per_atom']
        vasp_e = sdata['vasp_energy_per_atom']
        diff = vasp_e - mp_e
        all_diffs.append((mp_id, diff, abs(diff), sdata))
    
    # Detect statistical outliers using IQR method
    abs_diffs = [abs_diff for _, _, abs_diff, _ in all_diffs]
    q25, q75 = np.percentile(abs_diffs, [25, 75])
    iqr = q75 - q25
    outlier_threshold_iqr = q75 + 3 * iqr  # 3*IQR above Q3
    
    # Also use absolute threshold
    outlier_threshold_abs = outlier_threshold
    
    # Filter outliers
    skipped_outliers = []
    filtered_diffs = []
    
    for mp_id, diff, abs_diff, sdata in all_diffs:
        # Check both statistical and absolute thresholds
        if abs_diff > outlier_threshold_iqr or abs_diff > outlier_threshold_abs:
            skipped_outliers.append({
                'mp_id': mp_id,
                'formula': sdata['formula'],
                'mp_energy': sdata['mp_energy_per_atom'],
                'vasp_energy': sdata['vasp_energy_per_atom'],
                'diff': diff,
                'abs_diff': abs_diff
            })
            print(f"  WARNING: Excluding outlier {mp_id} ({sdata['formula']}): "
                  f"Δ = {diff:+.4f} eV/atom (|Δ| = {abs_diff:.4f})")
        else:
            filtered_diffs.append((mp_id, diff, abs_diff, sdata))
    
    if skipped_outliers:
        print(f"\n  Filtered out {len(skipped_outliers)} statistical outliers "
              f"(|Δ| > {outlier_threshold:.2f} eV/atom or > Q3+3*IQR)")
    
    print(f"  Analyzing {len(filtered_diffs)} structures after filtering\n")
    
    # Calculate differences from filtered data
    diffs = []
    by_chemsys = defaultdict(list)
    
    for mp_id, diff, abs_diff, sdata in filtered_diffs:
        mp_e = sdata['mp_energy_per_atom']
        vasp_e = sdata['vasp_energy_per_atom']
        
        diffs.append({
            'mp_id': mp_id,
            'chemsys': sdata['chemsys'],
            'formula': sdata['formula'],
            'mp_energy': mp_e,
            'vasp_energy': vasp_e,
            'diff': diff,
            'abs_diff': abs_diff
        })
        
        by_chemsys[sdata['chemsys']].append(diff)
    
    # Overall statistics (after filtering)
    diff_values = [d['diff'] for d in diffs]
    abs_diff_values = [d['abs_diff'] for d in diffs]
    
    stats = {
        'n_structures': len(diffs),
        'n_recovered_from_outcar': len(recovered_from_outcar),
        'n_skipped_no_energy': len(skipped_no_energy),
        'n_skipped_not_converged': len(skipped_not_converged),
        'n_skipped_outliers': len(skipped_outliers),
        'outlier_threshold': outlier_threshold,
        'mean_diff': np.mean(diff_values),
        'std_diff': np.std(diff_values),
        'mae': np.mean(abs_diff_values),
        'rmse': np.sqrt(np.mean([d**2 for d in diff_values])),
        'min_diff': np.min(diff_values),
        'max_diff': np.max(diff_values),
        'median_diff': np.median(diff_values),
        'q25': np.percentile(diff_values, 25),
        'q75': np.percentile(diff_values, 75)
    }
    
    # Per-chemsys statistics
    chemsys_stats = {}
    for chemsys, chemsys_diffs in by_chemsys.items():
        chemsys_stats[chemsys] = {
            'n': len(chemsys_diffs),
            'mean': np.mean(chemsys_diffs),
            'std': np.std(chemsys_diffs),
            'mae': np.mean([abs(d) for d in chemsys_diffs]),
            'max_abs': max([abs(d) for d in chemsys_diffs])
        }
    
    return {
        'stats': stats,
        'chemsys_stats': chemsys_stats,
        'structures': diffs,
        'recovered_from_outcar': recovered_from_outcar,
        'skipped_no_energy': skipped_no_energy,
        'skipped_not_converged': skipped_not_converged,
        'skipped_outliers': skipped_outliers
    }


def plot_energy_comparison(results, output_prefix='mp_vasp_comparison'):
    """
    Create scatter plot comparing MP vs VASP energies.
    
    Args:
        results: Analysis results dictionary
        output_prefix: Prefix for output files
    """
    structures = results['structures']
    stats = results['stats']
    
    # Extract data
    vasp_energies = np.array([s['vasp_energy'] for s in structures])
    mp_energies = np.array([s['mp_energy'] for s in structures])
    formulas = [s['formula'] for s in structures]
    
    # Create figure
    fig, ax = plt.subplots(figsize=(12, 10))
    
    # Scatter plot
    ax.scatter(vasp_energies, mp_energies, alpha=0.6, s=50, c='steelblue', edgecolors='black', linewidth=0.5)
    
    # Perfect agreement line (y = x)
    all_energies = np.concatenate([vasp_energies, mp_energies])
    energy_min, energy_max = all_energies.min(), all_energies.max()
    margin = (energy_max - energy_min) * 0.05
    plot_min, plot_max = energy_min - margin, energy_max + margin
    
    ax.plot([plot_min, plot_max], [plot_min, plot_max], 'r--', linewidth=2, alpha=0.7, 
            label='Perfect agreement (y=x)')
    
    # Add error bands (±0.05 eV/atom)
    ax.fill_between([plot_min, plot_max], 
                     [plot_min - 0.05, plot_max - 0.05],
                     [plot_min + 0.05, plot_max + 0.05],
                     alpha=0.2, color='green', label='±0.05 eV/atom')
    
    # Labels and title
    ax.set_xlabel('VASP PBE Energy per Atom (eV)', fontsize=12, fontweight='bold')
    ax.set_ylabel('MP GGA-PBE Energy per Atom (eV)', fontsize=12, fontweight='bold')
    n_skipped_conv = stats.get('n_skipped_not_converged', 0)
    n_skipped_outliers = stats.get('n_skipped_outliers', 0)
    title_suffix = f' (Pure GGA-PBE, N={stats["n_structures"]}'
    if n_skipped_conv > 0 or n_skipped_outliers > 0:
        title_suffix += ', excluded:'
        if n_skipped_conv > 0:
            title_suffix += f' {n_skipped_conv} non-converged'
        if n_skipped_outliers > 0:
            if n_skipped_conv > 0:
                title_suffix += ','
            title_suffix += f' {n_skipped_outliers} outliers'
    title_suffix += ')'
    ax.set_title(f'MP vs VASP DFT Energy Comparison\n{title_suffix}', 
                 fontsize=14, fontweight='bold')
    
    # Add statistics text box
    stats_text = (
        f"N = {stats['n_structures']}\n"
        f"MAE = {stats['mae']:.4f} eV/atom\n"
        f"RMSE = {stats['rmse']:.4f} eV/atom\n"
        f"Mean Diff = {stats['mean_diff']:+.4f} eV/atom\n"
        f"Std Diff = {stats['std_diff']:.4f} eV/atom"
    )
    ax.text(0.05, 0.95, stats_text, transform=ax.transAxes, fontsize=10,
            verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
    
    # Grid and legend
    ax.grid(True, alpha=0.3, linestyle='--')
    ax.minorticks_on()
    ax.grid(True, which='minor', alpha=0.15, linestyle=':')
    ax.legend(loc='lower right', fontsize=10)
    
    # Equal aspect ratio
    ax.set_aspect('equal', adjustable='box')
    ax.set_xlim(plot_min, plot_max)
    ax.set_ylim(plot_min, plot_max)
    
    # Save figure
    plt.tight_layout()
    plot_file = f"{output_prefix}_scatter.png"
    plt.savefig(plot_file, dpi=300, bbox_inches='tight')
    print(f"\nScatter plot saved to: {plot_file}")
    plt.close()
    
    # Create residual plot
    fig, ax = plt.subplots(figsize=(12, 10))
    
    # Residual vs VASP energy
    residuals = vasp_energies - mp_energies
    ax.scatter(vasp_energies, residuals, alpha=0.6, s=50, c='steelblue', edgecolors='black', linewidth=0.5)
    
    # Reference lines
    ax.axhline(y=0, color='r', linestyle='--', linewidth=2, alpha=0.7, label='Zero residual')
    ax.axhline(y=0.05, color='green', linestyle=':', linewidth=1.5, alpha=0.6, label='±0.05 eV/atom')
    ax.axhline(y=-0.05, color='green', linestyle=':', linewidth=1.5, alpha=0.6)
    
    # Mean residual line
    ax.axhline(y=stats['mean_diff'], color='orange', linestyle='-', linewidth=2, 
               alpha=0.7, label=f'Mean = {stats["mean_diff"]:+.4f} eV/atom')
    
    # Labels and title
    ax.set_xlabel('VASP PBE Energy per Atom (eV)', fontsize=12, fontweight='bold')
    ax.set_ylabel('Residual (VASP - MP) (eV/atom)', fontsize=12, fontweight='bold')
    n_skipped_conv = stats.get('n_skipped_not_converged', 0)
    n_skipped_outliers = stats.get('n_skipped_outliers', 0)
    title_suffix = f' (Pure GGA-PBE, N={stats["n_structures"]}'
    if n_skipped_conv > 0 or n_skipped_outliers > 0:
        title_suffix += ', excluded:'
        if n_skipped_conv > 0:
            title_suffix += f' {n_skipped_conv} non-converged'
        if n_skipped_outliers > 0:
            if n_skipped_conv > 0:
                title_suffix += ','
            title_suffix += f' {n_skipped_outliers} outliers'
    title_suffix += ')'
    ax.set_title(f'Energy Residuals vs VASP Energy\n{title_suffix}', 
                 fontsize=14, fontweight='bold')
    
    # Set focused Y-axis range based on data
    residual_range = max(abs(residuals.min()), abs(residuals.max()))
    # Use ±0.15 eV/atom or 1.5x the max residual, whichever is larger
    y_limit = max(0.15, residual_range * 1.5)
    ax.set_ylim(-y_limit, y_limit)
    
    # Grid with minor ticks
    ax.grid(True, alpha=0.3, linestyle='--')
    ax.minorticks_on()
    ax.grid(True, which='minor', alpha=0.15, linestyle=':')
    
    # Legend
    ax.legend(loc='best', fontsize=10)
    
    # Save figure
    plt.tight_layout()
    residual_file = f"{output_prefix}_residuals.png"
    plt.savefig(residual_file, dpi=300, bbox_inches='tight')
    print(f"Residual plot saved to: {residual_file}")
    plt.close()


def print_summary(results):
    """Print minimal analysis summary."""
    stats = results['stats']
    
    print("\n" + "="*70)
    print("MP vs VASP Energy Comparison (Pure GGA-PBE Functional)")
    print("="*70)
    print(f"Structures analyzed: {stats['n_structures']}")
    if stats.get('n_recovered_from_outcar', 0) > 0:
        print(f"Recovered from OUTCAR (timed out): {stats['n_recovered_from_outcar']}")
    if stats.get('n_skipped_no_energy', 0) > 0:
        print(f"Skipped (no energy): {stats['n_skipped_no_energy']}")
    if stats.get('n_skipped_not_converged', 0) > 0:
        print(f"Skipped (not converged): {stats['n_skipped_not_converged']}")
    if stats.get('n_skipped_outliers', 0) > 0:
        print(f"Skipped (statistical outliers): {stats['n_skipped_outliers']}")
    print(f"MAE:  {stats['mae']:.4f} eV/atom")
    print(f"RMSE: {stats['rmse']:.4f} eV/atom")
    print(f"Mean: {stats['mean_diff']:+.4f} eV/atom")
    print("="*70)


def save_detailed_comparison(results, output_file, mp_energies_file):
    """Save detailed comparison to JSON file."""
    # Add metadata about functional filtering, convergence checking, and outlier removal
    results['metadata'] = {
        'functional': 'GGA-PBE',
        'note': 'MP energies loaded from JSON file (generated by get_mp_struct.py or compute_dft_e_hull.py)',
        'mp_energies_source': str(mp_energies_file),
        'mp_field_used': 'energy_per_atom (uncorrected GGA-PBE energy, raw DFT)',
        'convergence_check': 'Only converged VASP calculations included (checks vasprun.xml, falls back to OUTCAR for timeouts)',
        'timeout_handling': 'Timed-out jobs with electronic convergence recovered from OUTCAR',
        'outlier_detection': 'Statistical outliers excluded using IQR method and absolute threshold',
        'outlier_threshold': results['stats'].get('outlier_threshold', 0.5),
        'n_recovered_from_outcar': results['stats'].get('n_recovered_from_outcar', 0),
        'n_skipped_no_energy': results['stats'].get('n_skipped_no_energy', 0),
        'n_skipped_not_converged': results['stats'].get('n_skipped_not_converged', 0),
        'n_skipped_outliers': results['stats'].get('n_skipped_outliers', 0)
    }
    
    with open(output_file, 'w') as f:
        json.dump(results, f, indent=2)
    
    print(f"\nDetailed results saved to: {output_file}")
    print(f"  (MP GGA-PBE from {mp_energies_file.name} vs converged VASP PBE, outliers excluded)")


def main():
    parser = argparse.ArgumentParser(
        description="Compare MP and VASP energies from workflow database"
    )
    parser.add_argument(
        '--db',
        type=str,
        default='./mp_relax_workflow.json',
        help="Workflow database file (default: ./mp_relax_workflow.json)"
    )
    parser.add_argument(
        '--mp-energies-file',
        type=str,
        default=None,
        help="Path to mp_vaspdft.json file with MP GGA-PBE energies. "
             "Generated by get_mp_struct.py (mp_cache_structs/mp_vaspdft.json) or "
             "compute_dft_e_hull.py (VASP_JOBS/mp_vaspdft.json). "
             "If not specified, tries both default locations."
    )
    parser.add_argument(
        '--output',
        type=str,
        default='mp_vasp_comparison.json',
        help="Output file for detailed results (default: mp_vasp_comparison.json). "
             "Also generates PNG plots with same prefix."
    )
    parser.add_argument(
        '--no-convergence-check',
        action='store_true',
        help="Skip VASP convergence verification (include all completed structures)"
    )
    parser.add_argument(
        '--outlier-threshold',
        type=float,
        default=0.5,
        help="Absolute energy difference threshold (eV/atom) for outlier detection (default: 0.5)"
    )
    
    args = parser.parse_args()
    
    db_path = Path(args.db).expanduser()
    
    if not db_path.exists():
        print(f"ERROR: Database file not found: {db_path}")
        return 1
    
    # Determine MP energies file path
    if args.mp_energies_file:
        mp_energies_file = Path(args.mp_energies_file).expanduser()
    else:
        # Try default locations
        default_paths = [
            Path('./mp_cache_structs/mp_vaspdft.json'),
            Path('./VASP_JOBS/mp_vaspdft.json')
        ]
        
        mp_energies_file = None
        for path in default_paths:
            if path.exists():
                mp_energies_file = path
                break
        
        if mp_energies_file is None:
            print("ERROR: MP energies file not found!")
            print("\nTried default locations:")
            for path in default_paths:
                print(f"  - {path}")
            print("\nPlease specify --mp-energies-file or generate the file by running:")
            print("  1. get_mp_struct.py (saves to mp_cache_structs/mp_vaspdft.json), or")
            print("  2. compute_dft_e_hull.py (saves to VASP_JOBS/mp_vaspdft.json)")
        return 1
    
    # Load database
    print(f"Loading workflow database: {db_path}")
    db = load_workflow_db(db_path)
    
    total = len(db['structures'])
    completed = sum(1 for s in db['structures'].values() if s['state'] == 'COMPLETED')
    
    print(f"Total structures: {total}")
    print(f"Completed: {completed}")
    
    if completed == 0:
        print("\nNo completed structures found!")
        return 1
    
    # Get list of completed MP IDs
    completed_mp_ids = [mp_id for mp_id, s in db['structures'].items() 
                        if s['state'] == 'COMPLETED' and s['vasp_energy_per_atom'] is not None]
    
    # Load MP energies from JSON file
    try:
        mp_energies = load_mp_energies_from_json(mp_energies_file)
    except Exception as e:
        print(f"ERROR: Failed to load MP energies: {e}")
        return 1
    
    # Analyze
    print("\nAnalyzing energy differences...")
    check_convergence = not args.no_convergence_check
    if check_convergence:
        print("  (Verifying VASP convergence - use --no-convergence-check to disable)")
    print(f"  (Outlier threshold: |Δ| > {args.outlier_threshold:.2f} eV/atom)")
    results = analyze_energy_differences(
        db, mp_energies, 
        check_convergence=check_convergence,
        outlier_threshold=args.outlier_threshold
    )
    
    if results is None:
        print("ERROR: No valid energy data found")
        return 1
    
    # Print minimal summary
    print_summary(results)
    
    # Save detailed results
    output_prefix = args.output.replace('.json', '')
    save_detailed_comparison(results, args.output, mp_energies_file)
    
    # Generate plots
    print("\nGenerating comparison plots...")
    plot_energy_comparison(results, output_prefix=output_prefix)
    
    print("\n" + "="*70)
    print("Analysis complete!")
    print(f"  JSON results: {args.output}")
    print(f"  Scatter plot: {output_prefix}_scatter.png")
    print(f"  Residual plot: {output_prefix}_residuals.png")
    print(f"  MP energies from: {mp_energies_file}")
    print("="*70 + "\n")
    
    return 0


if __name__ == '__main__':
    import sys
    sys.exit(main())

